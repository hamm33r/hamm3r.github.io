
# 搜索算法的一些相关概念
## 搜索的概念
搜索是一种枚举，通过穷举所有的情况找到最优解，有时也叫暴搜
## 回溯与剪枝
回溯：当在搜索的过程中遇到走不通或者走到底的情况时，就回头
剪枝：减掉在搜索过程中，不合法或者重复的解
## 案例——输出一到n的全排列
n = 3，其实就是有3个空位_ _ _ ,每个空位可以是1，2， 3
在枚举全排列时，可以通过画树状图的方式进行排列
\_ _ _
1 _ _ ，  2 _ _，   3 _ _
1 2 _，   1 3 _，   2 1 _，   2 3 _
....
1 2 3 | 1 3 2 | 2 1 3 | 2 3 1 | 3 1 2 | 3 2 1
答案其实就是对这个树来一次深度优先搜索
# 例题 [枚举子集](https://www.luogu.com.cn/problem/B3622)
题目描述

今有 n 位同学，可以从中选出任意名同学参加合唱。

请输出所有可能的选择方案。
输入格式

仅一行，一个正整数 n。
输出格式

若干行，每行表示一个选择方案。

每一种选择方案用一个字符串表示，其中第 i 位为 Y 则表示第 i 名同学参加合唱；为 N 则表示不参加。

需要以字典序输出答案。
输入 3
输出
NNN
NNY
NYN
NYY
YNN
YNY
YYN
YYY
```c++
#include<iostream>
#include<string>
using namespace std;

string path;//保存搜索的路径
int n;//需要进行排列的位数

void dfs(int pos)//pos表示当前排列进行到哪一位
{
	//已经选完n位，需要输出
	if (pos > n)//递归进行到n+1层，说明前面的n位已经选完此时应输出结果并返回
	{
		cout << path << endl;
		return;
	}

	//这一位不选的情况
	path += 'N';
	dfs(pos + 1);//去选下一位
	path.pop_back();//程序运行到这里，说明上面的递归已经返回到了同一层，需要复原现场

	//这一位选的情况
	path += 'Y';
	dfs(pos + 1);//去选下一位
	path.pop_back();
}
int main()
{
	cin >> n;
	dfs(1);
	return 0;
}
```
回溯的关键代码 path.pop_back()


